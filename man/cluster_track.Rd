% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_track.R
\name{cluster_track}
\alias{cluster_track}
\title{Cluster a movement track into spatiotemporal clusters}
\usage{
cluster_track(
  ctdf,
  deltaT = 30,
  nmin = 3,
  minCluster = 3,
  area_z_min = 1,
  length_z_min = 1,
  trim = 0.05,
  aggregate_dist
)
}
\arguments{
\item{ctdf}{A \code{ctdf} object (see \code{\link[=as_ctdf]{as_ctdf()}}).}

\item{deltaT}{Numeric; passed to \code{\link[=slice_ctdf]{slice_ctdf()}}. Maximum allowable time gap (in days)
used when splitting candidate regions into movement segments.}

\item{nmin}{Integer; passed to \code{\link[=slice_ctdf]{slice_ctdf()}} (\code{nmin}) and \code{\link[=local_cluster_ctdf]{local_cluster_ctdf()}} (\code{nmin}).}

\item{minCluster}{Integer; minimum number of points required to keep a putative cluster
(clusters with \code{N <= minCluster} are dropped before final repairs).}

\item{area_z_min}{Numeric; pruning threshold forwarded to \code{\link[=local_cluster_ctdf]{local_cluster_ctdf()}} and
ultimately \code{\link[=sf_dtscan]{sf_dtscan()}} as \code{area_z_min} (sign is flipped internally).}

\item{length_z_min}{Numeric; pruning threshold forwarded to \code{\link[=local_cluster_ctdf]{local_cluster_ctdf()}} and
ultimately \code{\link[=sf_dtscan]{sf_dtscan()}} as \code{length_z_min} (sign is flipped internally).}

\item{trim}{Numeric; passed to \code{\link[=temporal_repair]{temporal_repair()}}. Maximum fraction trimmed from each
tail when estimating each cluster's time domain.}

\item{aggregate_dist}{Optional numeric; if supplied, passed to \code{\link[=aggregate_ctdf]{aggregate_ctdf()}} as \code{dist}
(numeric treated as km).}
}
\value{
Invisibly returns \code{ctdf}, with \code{cluster} updated in-place and
\code{attr(ctdf, "cluster_params")} set.
}
\description{
\code{cluster_track} that assigns a \code{cluster} id to each location in a \code{ctdf} by running a
multi-step pipeline:
\enumerate{
\item identify temporally continuous putative regions via \code{\link[=slice_ctdf]{slice_ctdf()}}.
\item merge adjacent putative regions with intersecting convex hulls via \code{\link[=spatial_repair]{spatial_repair()}}.
\item locally split each putative region using DTSCAN via \code{\link[=local_cluster_ctdf]{local_cluster_ctdf()}} and \code{\link[=sf_dtscan]{sf_dtscan()}}.
\item enforce non-overlap in time by merging any putative regions with
overlapping time domains via \code{\link[=temporal_repair]{temporal_repair()}}.
\item drop small clusters and run additional spatial and track-shape repairs via \code{\link[=spatial_repair]{spatial_repair()}}
and \code{\link[=tail_repair]{tail_repair()}}.
\item optionally merge adjacent clusters within \code{aggregate_dist} via \code{\link[=aggregate_ctdf]{aggregate_ctdf()}}.
}
}
\details{
The function updates \code{ctdf} by reference and stores its parameters in
\code{attr(ctdf, "cluster_params")}.
}
\examples{
data(mini_ruff)
ctdf = as_ctdf(mini_ruff) |> cluster_track()

\dontrun{
data(pesa56511)
pesa = as_ctdf(pesa56511, time = "locationDate") |> cluster_track()

data(ruff143789)
ruff = as_ctdf(ruff143789, time = "locationDate") |> cluster_track()


data(lbdo66862)
lbdo = as_ctdf(lbdo66862, time = "locationDate") |> cluster_track()


}
}
\seealso{
\code{\link[=as_ctdf]{as_ctdf()}}, \code{\link[=slice_ctdf]{slice_ctdf()}}, \code{\link[=spatial_repair]{spatial_repair()}}, \code{\link[=local_cluster_ctdf]{local_cluster_ctdf()}}, \code{\link[=sf_dtscan]{sf_dtscan()}},
\code{\link[=temporal_repair]{temporal_repair()}}, \code{\link[=tail_repair]{tail_repair()}}, \code{\link[=aggregate_ctdf]{aggregate_ctdf()}}
}
