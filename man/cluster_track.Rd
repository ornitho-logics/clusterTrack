% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_track.R
\name{cluster_track}
\alias{cluster_track}
\title{Cluster movement tracks}
\usage{
cluster_track(ctdf, deltaT = 30, nmin = 3, minCluster = 3, Q = 0.9)
}
\arguments{
\item{ctdf}{A `ctdf` data frame (see [as_ctdf()]) representing a single movement track .}

\item{deltaT}{Numeric; maximum allowable gap (in days) between segment endpoints to consider them non-intersecting.
Default to 1 day. Passed to [slice()]) .}

\item{nmin}{Integer. Segments or tessellations with fewer than nmin points yield no clusters.
Default to 3. Passed to [cluster_segments()].}

\item{threshold}{Numeric. the multiplier of the standard deviation
on log‐areas used in pruning. Passed to [cluster_segments()].}

\item{time_contiguity}{Logical; if `TRUE`, missing cluster IDs (usually spatial outliers) are  filled
within each cluster to enforce temporal continuity.
Default to `FALSE`.
Passed to [cluster_segments()].}

\item{overlap_threshold}{Numeric between 0 and 1; minimum area‐overlap ratio
required to merge adjacent clusters. Default to 0.1.
Clusters with overlap > threshold are combined.
Passed to [cluster_repair()]}
}
\value{
NULL.
The function modifies `ctdf` by reference, adding or updating the column \code{cluster},
which assigns a cluster ID to each row (point).
Clustering parameters are stored as an attribute: `attr(ctdf, "cluster_params")`.
}
\description{
Performs spatiotemporal clustering on a ctdf by segmenting movement, identifying stops, and applying DBSCAN-like clustering.
}
\details{
This is a high-level wrapper function that applies a pipeline of segmentation, clustering, and repairing steps on a movement track stored in a `ctdf` object.
}
\examples{
data(mini_ruff)
ctdf = as_ctdf(mini_ruff) |> cluster_track()
map(ctdf)

\dontrun{
data(pesa56511)
ctdf = as_ctdf(pesa56511, time = "locationDate") |> cluster_track()
map(ctdf)


data(ruff143789)
ctdf = as_ctdf(ruff143789, time = "locationDate") |> cluster_track()
map(ctdf)

data(lbdo66862)
ctdf = as_ctdf(lbdo66862, time = "locationDate") |> cluster_track()
map(ctdf)


}
}
