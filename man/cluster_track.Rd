% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster_track.R
\name{cluster_track}
\alias{cluster_track}
\title{Cluster a movement track into spatiotemporal clusters}
\usage{
cluster_track(
  ctdf,
  nmin = 3,
  z_min = 1,
  trim = 0.05,
  minCluster = 3,
  deltaT,
  aggregate_dist
)
}
\arguments{
\item{ctdf}{A \code{ctdf} object (see \code{\link[=as_ctdf]{as_ctdf()}}).}

\item{nmin}{Integer; passed to \code{\link[=local_cluster_ctdf]{local_cluster_ctdf()}} (\code{nmin}).
(clusters with \code{N <= minCluster} are dropped before final repairs).}

\item{z_min}{Numeric; pruning strictness in SD units.
Smaller values produce more compact clusters and often more unassigned points.
Implementation detail: the underlying thresholds use an inverse z-score convention,
so the sign is flipped internally; see \code{\link[=sf_dtscan]{sf_dtscan()}}  and \code{\link[=local_cluster_ctdf]{local_cluster_ctdf()}}.}

\item{trim}{Numeric; passed to \code{\link[=temporal_repair]{temporal_repair()}}. Maximum fraction trimmed from each}

\item{minCluster}{Integer; minimum number of points required to keep a putative cluster
used when splitting candidate regions into movement segments.
tail when estimating each cluster's time domain.}

\item{deltaT}{Optional numeric; passed to \code{\link[=slice_ctdf]{slice_ctdf()}}. Maximum allowable time gap (in days)}

\item{aggregate_dist}{Optional numeric; if supplied, passed to \code{\link[=aggregate_ctdf]{aggregate_ctdf()}} as \code{dist}
(numeric treated as km).}
}
\value{
Invisibly returns \code{ctdf}, with \code{cluster} updated in-place and
\code{attr(ctdf, "cluster_params")} set.
}
\description{
\code{cluster_track} that assigns a \code{cluster} id to each location in a \code{ctdf} by running a
multi-step pipeline:
\enumerate{
\item identify temporally continuous putative regions via \code{\link[=slice_ctdf]{slice_ctdf()}}.
\item merge temporally adjacent putative regions  via \code{\link[=spatial_repair]{spatial_repair()}}.
\item locally cluster each putative region using DTSCAN via  \code{\link[=sf_dtscan]{sf_dtscan()}}.
\item enforce non-overlap in time by merging any clusters with
overlapping time domains via \code{\link[=temporal_repair]{temporal_repair()}}.
\item drop small clusters and run additional spatial repairs via \code{\link[=spatial_repair]{spatial_repair()}}
and \code{\link[=tail_repair]{tail_repair()}}.
\item optionally merge adjacent clusters within \code{aggregate_dist} via \code{\link[=aggregate_ctdf]{aggregate_ctdf()}}.
}
}
\details{
The function updates \code{ctdf} by reference and stores its parameters in
\code{attr(ctdf, "cluster_params")}.
}
\examples{
data(mini_ruff)
x = as_ctdf(mini_ruff) |> cluster_track()

\dontrun{
data(pesa56511)
pesa = as_ctdf(pesa56511, time = "locationDate") |> cluster_track()

data(ruff143789)
ruff = as_ctdf(ruff143789, time = "locationDate") |> cluster_track()

data(ruff07b5)
lbdo = as_ctdf(ruff07b5, time = "timestamp") |> cluster_track()

data(lbdo66862)
lbdo2 = as_ctdf(lbdo66862, time = "locationDate") |> cluster_track()

data(nola125a)
nola = as_ctdf(nola125a, time = "timestamp") |> cluster_track()


}
}
\seealso{
\code{\link[=as_ctdf]{as_ctdf()}}, \code{\link[=slice_ctdf]{slice_ctdf()}}, \code{\link[=spatial_repair]{spatial_repair()}}, \code{\link[=local_cluster_ctdf]{local_cluster_ctdf()}}, \code{\link[=sf_dtscan]{sf_dtscan()}},
\code{\link[=temporal_repair]{temporal_repair()}}, \code{\link[=tail_repair]{tail_repair()}}, \code{\link[=aggregate_ctdf]{aggregate_ctdf()}}
}
